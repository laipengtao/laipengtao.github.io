<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分享会-spring activity</title>
    <link href="/2021/02/01/%E5%88%86%E4%BA%AB%E4%BC%9A-spring%20activity/"/>
    <url>/2021/02/01/%E5%88%86%E4%BA%AB%E4%BC%9A-spring%20activity/</url>
    
    <content type="html"><![CDATA[<h1 id="了解一下Activity工作流"><a href="#了解一下Activity工作流" class="headerlink" title="了解一下Activity工作流"></a>了解一下Activity工作流</h1><p><strong>谈谈平常我们所接触到的关于流程的事：</strong></p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">请假流程，钉钉申请流程</span><br><span class="hljs-comment"></span>   <span class="hljs-comment">员工请假</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">》主管审批</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">》经理审批</span><br></code></pre></td></tr></table></figure><p><strong>工作流有什么优点（你平常做这些流程性的需求你会怎么做）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">工作流系统，实现了工作流程的自动化，提高了企业运营效率、改善企业资源利用、提高企业运作的灵活性和适应性、提高量化考核业务处理的效率、减少浪费（时间就是金钱）。<br><br>而手工处理工作流程，一方面无法对整个流程状况进行有效跟踪、了解，另一方面难免会出现人为的失误和时间上的延时导致效率低下，特别是无法进行量化统计，不利于查询、报表及绩效评估。<br></code></pre></td></tr></table></figure><p><strong>Activity是怎么做的？</strong>        </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Activiti</span>框架底层有数据库提供支持，根据版本不同，表的数量不一致，activiti<span class="hljs-number">5</span>.<span class="hljs-number">13</span>有<span class="hljs-number">23</span>张表。底层使用mybatis操作数据库，开发人员不需要自己编写sql，只需要运用bpmn构建出自己的流程图，运用框架就可以实现自己所需要的业务流程<br></code></pre></td></tr></table></figure><p><strong>了解该数据表所存储的内容</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">Activiti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。<br><br><span class="hljs-number">1</span>) ACT_RE_*: <span class="hljs-string">&#x27;RE&#x27;</span>表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。<br><br><span class="hljs-number">2</span>) ACT_RU_*: <span class="hljs-string">&#x27;RU&#x27;</span>表示<span class="hljs-keyword">runtime</span>。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。<br><br><span class="hljs-number">3</span>) ACT_ID_*: <span class="hljs-string">&#x27;ID&#x27;</span>表示identity。 这些表包含身份信息，比如用户，组等等。<br><br><span class="hljs-number">4</span>) ACT_HI_*: <span class="hljs-string">&#x27;HI&#x27;</span>表示<span class="hljs-keyword">history</span>。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。<br><br><span class="hljs-number">5</span>) ACT_GE_*: 通用数据， 用于不同场景下。<br></code></pre></td></tr></table></figure><p><img src="https://img.jbzj.com/file_images/article/202004/202004291425413.png" alt="20160605225438184"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//调用引擎,初始化</span><br>    ProcessEngine processEngine = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ProcessEngines</span>.</span></span>get<span class="hljs-constructor">DefaultProcessEngine()</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 部署流程定义</span><br><span class="hljs-comment">     */</span><br>    @Test<br>    public void deployment<span class="hljs-literal">()</span> &#123;<br>        Deployment deployment = processEngine.get<span class="hljs-constructor">RepositoryService()</span><span class="hljs-comment">//与流程定义和部署相关的Service</span><br>                .create<span class="hljs-constructor">Deployment()</span><span class="hljs-comment">//创建一个部署对象</span><br>                .name(<span class="hljs-string">&quot;helloword&quot;</span>)<span class="hljs-comment">//添加部署的名称</span><br>                .add<span class="hljs-constructor">ClasspathResource(<span class="hljs-string">&quot;diagrams/helloword.bpmn&quot;</span>)</span><span class="hljs-comment">//从classpath下加载资源，一次一个</span><br>                .add<span class="hljs-constructor">ClasspathResource(<span class="hljs-string">&quot;diagrams/helloword.png&quot;</span>)</span><br>                .deploy<span class="hljs-literal">()</span>;<span class="hljs-comment">//完成部署</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;部署ID&quot;</span>+deployment.get<span class="hljs-constructor">Id()</span>);<span class="hljs-comment">//1</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;部署名称&quot;</span>+deployment.get<span class="hljs-constructor">Name()</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *启动流程实例</span><br><span class="hljs-comment">     */</span><br>    @Test<br>    public void start<span class="hljs-constructor">ProcessInstance()</span> &#123;<br>        String processDefinitionKey = <span class="hljs-string">&quot;helloword&quot;</span>;<br>        ProcessInstance processInstance = processEngine.get<span class="hljs-constructor">RuntimeService()</span><span class="hljs-comment">//与正在执行的流程实例和执行对象相关的Service</span><br>                .start<span class="hljs-constructor">ProcessInstanceByKey(<span class="hljs-params">processDefinitionKey</span>)</span>;<span class="hljs-comment">//根据Key值来查询流程,也可以根据ID</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;流程实例ID:&quot;</span>+processInstance.get<span class="hljs-constructor">Id()</span>);  <span class="hljs-comment">//2501</span><br>                                                                    <span class="hljs-comment">//对应数据库act_ru_execution</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;流程定义ID:&quot;</span>+processInstance.get<span class="hljs-constructor">ProcessDefinitionId()</span>); <span class="hljs-comment">//helloword:1:4</span><br>                                                                                <span class="hljs-comment">//对应数据库act_re_deployment</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询当前个人的任务</span><br><span class="hljs-comment">     */</span><br>    @Test<br>    public void fing<span class="hljs-constructor">ByPerson()</span> &#123;<br>        String assignee = <span class="hljs-string">&quot;张三&quot;</span>;<br>        List&lt;Task&gt; <span class="hljs-built_in">list</span> = processEngine.get<span class="hljs-constructor">TaskService()</span><span class="hljs-comment">//与正在执行的任务管理相关的Service</span><br>                .create<span class="hljs-constructor">TaskQuery()</span><span class="hljs-comment">//创建任务查询对象</span><br>                .task<span class="hljs-constructor">Assignee(<span class="hljs-params">assignee</span>)</span><span class="hljs-comment">//指定个人任务查询，指定代理人</span><br>                .<span class="hljs-built_in">list</span><span class="hljs-literal">()</span>;<span class="hljs-comment">//以list形式记录对象</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span> != null<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-built_in">list</span>.size<span class="hljs-literal">()</span>&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span>(Task task:<span class="hljs-built_in">list</span>) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;任务ID:&quot;</span>+task.get<span class="hljs-constructor">Id()</span>);<span class="hljs-comment">//2501</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;任务名称：&quot;</span>+task.get<span class="hljs-constructor">Name()</span>);<span class="hljs-comment">//提交申请</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;任务的创建时间：&quot;</span>+task.get<span class="hljs-constructor">CreateTime()</span>);<span class="hljs-comment">//Wed Jun 06 18:12:15 CST 2018</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;任务的代理人：&quot;</span>+task.get<span class="hljs-constructor">Assignee()</span>);<span class="hljs-comment">//张三</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;流程实例ID：&quot;</span>+task.get<span class="hljs-constructor">ProcessInstanceId()</span>);<span class="hljs-comment">//2501</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;执行对象ID：&quot;</span>+task.get<span class="hljs-constructor">ExecutionId()</span>);<span class="hljs-comment">//2501</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;流程定义ID：&quot;</span>+task.get<span class="hljs-constructor">ProcessDefinitionId()</span>);<span class="hljs-comment">//helloword:1:4</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 完成个人任务</span><br><span class="hljs-comment">     */</span><br>    @Test<br>    public void complete<span class="hljs-literal">()</span> &#123;<br>        String taskId = <span class="hljs-string">&quot;2504&quot;</span>;<br>        processEngine.get<span class="hljs-constructor">TaskService()</span><br>            .complete(taskId );<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;完成任务ID：&quot;</span>+taskId);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分享会-对Mysql索引数据结构剖析</title>
    <link href="/2020/12/01/%E5%88%86%E4%BA%AB%E4%BC%9A-%E5%AF%B9Mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/"/>
    <url>/2020/12/01/%E5%88%86%E4%BA%AB%E4%BC%9A-%E5%AF%B9Mysql%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>1、MySQL索引数据结构</p><p>2、MySQL执行计划与索引实践</p><p>3、SQL底层执行原理</p><p>4、索引优化</p><p>5、MySQL锁与事务隔离级别</p><p>6、MVCC底层原理</p><p>7、MySQL日志</p><h1 id="MySQL索引数据结构"><a href="#MySQL索引数据结构" class="headerlink" title="MySQL索引数据结构"></a>MySQL索引数据结构</h1><p><strong>索引：</strong>是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong>。</p><p><strong>数据结构：</strong></p><ul><li><strong>二叉树:</strong> 单边递增，等于全表扫描。</li><li><strong>红黑树:</strong> 二叉平衡树，单边过大会自动平衡。大数据量的情况下树的高度不可控。</li><li><strong>Hash表：</strong>对索引的Key进行一次Hash计算就可以定位出数据存储的位置；很多时候hash索引要比B+树索引更高效；但是仅能满足 =、in 查询，不支持范围查询；hash冲突问题</li><li><strong>B-Tree</strong>: 叶节点具有相同的深度，叶节点的指针为空；所有索引元素不重复；节点中的数据索引从左到右递增排列</li><li><strong>B+Tree：</strong>(B-Tree的变种)  非叶子节点不存储data，只存储索引（冗余索引），可以存放更多的索引；叶子节点包含所有索引字段；叶子节点用双向指针连接，提高区间访问的性能</li></ul><p><strong>数据表：</strong></p><table><thead><tr><th></th><th>col1</th><th>col2</th></tr></thead><tbody><tr><td>0x01</td><td>1</td><td>50</td></tr><tr><td>0x02</td><td>2</td><td>43</td></tr><tr><td>0x03</td><td>3</td><td>65</td></tr><tr><td>0x04</td><td>4</td><td>23</td></tr><tr><td>0x05</td><td>5</td><td>44</td></tr><tr><td>0x06</td><td>6</td><td>78</td></tr><tr><td>0x07</td><td>7</td><td>91</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> t <span class="hljs-keyword">WHERE</span> t.col2 <span class="hljs-operator">=</span> <span class="hljs-number">78</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> t <span class="hljs-keyword">WHERE</span> t.col1 <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>二叉树：</p><p><img src="https://s3.ax1x.com/2021/03/01/6i5h3F.png" alt="1602988920229"></p><p>B-Tree：</p><p>data：磁盘文件所在地址，也有可能是整行数据记录。与存储引擎有关。</p><p><img src="https://s3.ax1x.com/2021/03/01/6i54c4.png" alt="1602990051836"></p><p>B+Tree：</p><p><img src="https://s3.ax1x.com/2021/03/01/6i57H1.png" alt="1602990750336"></p><p>B+Tree查找数据过程：</p><p>假设查找col=30 （折半算法）</p><ol><li>从根节点开始查找，首先将根节点元素load到内存中；</li><li>根据折半算法继续将冗余索引load到内存；</li><li>继续查找到col=30的索引，再根据磁盘文件地址查找对应的数据记录。</li></ol><p><strong>思考？</strong>内存中根据折半算法比对相较于磁盘I/O时间可忽略不计，那是否可以将所有叶子节点全部load到内存？</p><p><strong>升级！</strong>非叶子节点常驻内存。</p><p>B+Tree索引元素大小</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Innodb_page_size&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s3.ax1x.com/2021/03/01/6i5bAx.png" alt="1602991493677"></p><p>bigint：8Byte</p><p>地址文件：6Byte</p><p>16*1024/14=1170</p><p>查看MySQL安装位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> &quot;%char%&quot;;<br></code></pre></td></tr></table></figure><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p><strong>MyISAM:</strong> 索引文件和数据文件是分离的（非聚集）,早期用的多。</p><p><img src="https://s3.ax1x.com/2021/03/01/6i5X9O.png" alt="1603013076316"></p><p>*.frm</p><p>*.MYD</p><p>*.MYI</p><p><strong>InnoDB:</strong> 现在用的多，<strong>聚集索引：</strong>叶节点包含了完整的数据记录。</p><p>*.frm</p><p>*.ibd</p><p><strong>InnoDB主键索引</strong></p><p>叶子节点存储的是完整的数据记录</p><p><img src="https://s3.ax1x.com/2021/03/01/6iISud.png" alt="1603013957536"></p><p><strong>思考？</strong>为什么InnoDB表建议建立主键，并且推荐主键使用整型的<strong>自增</strong>主键？</p><p><strong>InnoDB非主键索引</strong></p><p>叶子节点存储的是主键值，并非完整的数据记录。</p><p>为什么非主键索引结构叶子节点存储的是主键值？（一致性、节省存储空间）</p><p><img src="https://s3.ax1x.com/2021/03/01/6iIF4f.png" alt="1603110654354"></p><p><strong>Hash</strong></p><p><img src="https://s3.ax1x.com/2021/03/01/6iImuj.png" alt="1603109798963"></p><p><strong>联合索引</strong></p><p><img src="https://s3.ax1x.com/2021/03/01/6iIubn.png" alt="1603111920345"></p><p><strong>思考？</strong>以下三句sql，分别会走索引吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bill&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> position <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;dev&#x27;</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> position <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;manager&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分享会-Docker</title>
    <link href="/2020/08/05/%E5%88%86%E4%BA%AB%E4%BC%9A-Docker/"/>
    <url>/2020/08/05/%E5%88%86%E4%BA%AB%E4%BC%9A-Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="谈一下最近Docker的学习"><a href="#谈一下最近Docker的学习" class="headerlink" title="谈一下最近Docker的学习"></a>谈一下最近Docker的学习</h1><h3 id="讲个故事"><a href="#讲个故事" class="headerlink" title="讲个故事"></a>讲个故事</h3><h6 id="因为这里网上有贴吧对Docker有更好的解释，所以我们就不展开联想直接用"><a href="#因为这里网上有贴吧对Docker有更好的解释，所以我们就不展开联想直接用" class="headerlink" title="因为这里网上有贴吧对Docker有更好的解释，所以我们就不展开联想直接用~~~"></a>因为这里网上有贴吧对Docker有更好的解释，所以我们就不展开联想直接用~~~</h6><p>为了更好的理解 <code>Docker</code> 是什么，我们先来讲个故事：</p><p>我需要盖一个房子，于是我搬石头、砍木头、画图纸、盖房子。一顿操作，终于把这个房子盖好了。</p><p><img src="https://s3.ax1x.com/2021/03/01/6iGjld.png"></p><p>结果，住了一段时间，心血来潮想搬到海边去。这时候按以往的办法，我只能去海边，再次搬石头、砍木头、画图纸、盖房子。</p><p><img src="https://s3.ax1x.com/2021/03/01/6iJp0P.png"></p><p>烦恼之际，跑来一个魔法师教会我一种魔法。这种魔法可以把我盖好的房子复制一份，做成「镜像」，放在我的背包里。</p><p><img src="https://s3.ax1x.com/2021/03/01/6iJZXn.png"></p><p>等我到了海边，就用这个「镜像」，复制一套房子，拎包入住。</p><p>是不是很神奇？对应到我们的项目中来，房子就是项目本身，镜像就是项目的复制，背包就是镜像仓库。如果要动态扩容，从仓库中取出项目镜像，随便复制就可以了。Build once，Run anywhere!</p><p>不用再关注版本、兼容、部署等问题，彻底解决了「上线即崩，无休止构建」的尴尬。</p><h4 id="认识Docker"><a href="#认识Docker" class="headerlink" title="认识Docker"></a>认识Docker</h4><h6 id="如果你想要了解Docker你首先要了解容器的概念"><a href="#如果你想要了解Docker你首先要了解容器的概念" class="headerlink" title="如果你想要了解Docker你首先要了解容器的概念"></a>如果你想要了解Docker你首先要了解容器的概念</h6><p><strong>容器</strong>：将操作系统层虚拟化，是一个标准的软件单元</p><ul><li>随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。</li><li>高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置 <code>CPU</code> 和内存的使用率，进而更好地利用服务器的计算资源。</li><li>快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。</li></ul><h6 id="Docker-轻量级的原因？"><a href="#Docker-轻量级的原因？" class="headerlink" title="Docker 轻量级的原因？"></a><strong><code>Docker</code> 轻量级的原因？</strong></h6><p>相信你也会有这样的疑惑：为什么 <code>Docker</code> 启动快？如何做到和宿主机共享内核？</p><p>当我们请求 <code>Docker</code> 运行容器时，<code>Docker</code> 会在计算机上设置一个资源隔离的环境。然后将打包的应用程序和关联的文件复制到 <code>Namespace</code> 内的文件系统中，此时环境的配置就完成了。之后 <code>Docker</code> 会执行我们预先指定的命令，运行应用程序。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h6 id="这里就不介绍怎么装Docker了，直接开始我们的试用"><a href="#这里就不介绍怎么装Docker了，直接开始我们的试用" class="headerlink" title="这里就不介绍怎么装Docker了，直接开始我们的试用"></a>这里就不介绍怎么装Docker了，直接开始我们的试用</h6><ol><li><p><strong>首先需要大致了解一下我们将会用到的 <code>11</code> 个命令</strong></p><p><img src="https://s3.ax1x.com/2021/03/01/6iY6GF.jpg"></p></li></ol><p>2.我们尝试着部署一个redis容器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull redis</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201120203211432.png#pic_center"></p><h6 id="启动镜像生成容器"><a href="#启动镜像生成容器" class="headerlink" title="启动镜像生成容器"></a>启动镜像生成容器</h6><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> -d <span class="hljs-comment">--name redis -p 6379:6379 redis</span><br></code></pre></td></tr></table></figure><h6 id="查询容器"><a href="#查询容器" class="headerlink" title="查询容器"></a>查询容器</h6><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker ps</span> <br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull redis</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201120203436264.png#pic_left"></p><h6 id="执行成功"><a href="#执行成功" class="headerlink" title="执行成功"></a>执行成功</h6><p><img src="https://img-blog.csdnimg.cn/20201120203537986.png#pic_center"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分享会-哈希一致</title>
    <link href="/2020/06/08/%E5%88%86%E4%BA%AB%E4%BC%9A-%E5%93%88%E5%B8%8C%E4%B8%80%E8%87%B4/"/>
    <url>/2020/06/08/%E5%88%86%E4%BA%AB%E4%BC%9A-%E5%93%88%E5%B8%8C%E4%B8%80%E8%87%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="Hash一致性算法"><a href="#Hash一致性算法" class="headerlink" title="Hash一致性算法"></a>Hash一致性算法</h1><h4 id="我们先思考平常所接触到的哈希算法以及判断好坏的四个定义"><a href="#我们先思考平常所接触到的哈希算法以及判断好坏的四个定义" class="headerlink" title="我们先思考平常所接触到的哈希算法以及判断好坏的四个定义"></a>我们先思考平常所接触到的哈希算法以及判断好坏的四个定义</h4><ol><li>平衡性(Balance)： 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li><li> 单调性(Monotonicity)： 单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</li><li> 分散性(Spread)： 在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由    于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的。</li><li>负载(Load)： 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li></ol><h4 id="Hash一致性算法的好处"><a href="#Hash一致性算法的好处" class="headerlink" title="Hash一致性算法的好处"></a>Hash一致性算法的好处</h4><h6 id="考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要。"><a href="#考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要。" class="headerlink" title="考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要。"></a>考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来，如何保证当系统的节点数目发生变化时仍然能够对外提供良好的服务，这是值得考虑的，尤其实在设计分布式缓存系统时，如果某台服务器失效，对于整个系统来说如果不采用合适的算法来保证一致性，那么缓存于系统中的所有数据都可能会失效（即由于系统节点数目变少，客户端在请求某一对象时需要重新计算其hash值（通常与系统中的节点数目有关），由于hash值已经改变，所以很可能找不到保存该对象的服务器节点），因此一致性hash就显得至关重要。</h6><h4 id="我们先看看Hash环的面目"><a href="#我们先看看Hash环的面目" class="headerlink" title="我们先看看Hash环的面目"></a>我们先看看Hash环的面目</h4><p><img src="https://s3.ax1x.com/2021/03/01/6iMdzt.png"></p><h6 id="hash环就是一个圆圈，因为按照常用的hash算法来将对应的key哈希到一个具有2-32次方个桶的空间中，即0-2-32-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如上图"><a href="#hash环就是一个圆圈，因为按照常用的hash算法来将对应的key哈希到一个具有2-32次方个桶的空间中，即0-2-32-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如上图" class="headerlink" title="hash环就是一个圆圈，因为按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如上图"></a>hash环就是一个圆圈，因为按照常用的hash算法来将对应的key哈希到一个具有2^32次方个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如上图</h6><h4 id="这时候我们试着将数据映射到hash环上"><a href="#这时候我们试着将数据映射到hash环上" class="headerlink" title="这时候我们试着将数据映射到hash环上"></a>这时候我们试着将数据映射到hash环上</h4><h5 id="首先将四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。"><a href="#首先将四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。" class="headerlink" title="首先将四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。"></a>首先将四个对象通过特定的Hash函数计算出对应的key值，然后散列到Hash环上。</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(object1)</span></span> = key1；<br><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(object2)</span></span> = key2；<br><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(object3)</span></span> = key3；<br><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(object4)</span></span> = key4；<br></code></pre></td></tr></table></figure><p><img src="https://s3.ax1x.com/2021/03/01/6iQDpR.jpg"></p><h5 id="然后将机器通过hash算法映射到环上"><a href="#然后将机器通过hash算法映射到环上" class="headerlink" title="然后将机器通过hash算法映射到环上"></a>然后<strong>将机器通过hash算法映射到环上</strong></h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Hash</span>(NODE<span class="hljs-number">1</span>) = KEY<span class="hljs-number">1</span>;<br><span class="hljs-attribute">Hash</span>(NODE<span class="hljs-number">2</span>) = KEY<span class="hljs-number">2</span>;<br><span class="hljs-attribute">Hash</span>(NODE<span class="hljs-number">3</span>) = KEY<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s3.ax1x.com/2021/03/01/6iQXNQ.jpg"></p><h4 id="机器的删除与添加"><a href="#机器的删除与添加" class="headerlink" title="机器的删除与添加"></a><strong>机器的删除与添加</strong></h4><h6 id="1-节点（机器）的删除"><a href="#1-节点（机器）的删除" class="headerlink" title="1.节点（机器）的删除"></a>1.节点（机器）的删除</h6><p>以上面的分布为例，如果NODE2出现故障被删除了，那么按照顺时针迁移的方法，object3将会被迁移到NODE3中，这样仅仅是object3的映射位置发生了变化，其它的对象没有任何的改动。如下图：</p><p><img src="https://s3.ax1x.com/2021/03/01/6iltgI.png"></p><h6 id="2-节点（机器）的添加"><a href="#2-节点（机器）的添加" class="headerlink" title="2.节点（机器）的添加"></a>2.节点（机器）的添加</h6><p>如果往集群中添加一个新的节点NODE4，通过对应的哈希算法得到KEY4，并映射到环中，如下图：</p><p><img src="https://s3.ax1x.com/2021/03/01/6ilvVO.jpg"></p><h4 id="最后在来讲讲这样映射后的弊端"><a href="#最后在来讲讲这样映射后的弊端" class="headerlink" title="最后在来讲讲这样映射后的弊端"></a>最后在来讲讲这样映射后的弊端</h4><h6 id="将会造成很多hash节点都指定到同一个机器上，我们要怎么解决该问题呢。。。我们可以通过虚拟节点方式映射到这个圈的个个地方，这样就能够解决平衡性的问题"><a href="#将会造成很多hash节点都指定到同一个机器上，我们要怎么解决该问题呢。。。我们可以通过虚拟节点方式映射到这个圈的个个地方，这样就能够解决平衡性的问题" class="headerlink" title="将会造成很多hash节点都指定到同一个机器上，我们要怎么解决该问题呢。。。我们可以通过虚拟节点方式映射到这个圈的个个地方，这样就能够解决平衡性的问题"></a>将会造成很多hash节点都指定到同一个机器上，我们要怎么解决该问题呢。。。我们可以通过虚拟节点方式映射到这个圈的个个地方，这样就能够解决平衡性的问题</h6><p><img src="https://s3.ax1x.com/2021/03/01/6i3dAS.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/01/hello-world/"/>
    <url>/2020/05/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
